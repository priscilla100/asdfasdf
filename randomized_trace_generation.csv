LTL Formula,Trace,Type
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=false,x2=true,x3=false];[x1=true,x2=true,x3=true];[x1=true,x2=false,x3=true];[x1=false,x2=true,x3=false];...",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=false,x2=false,x3=false];[x1=true,x2=true,x3=false];[x1=false,x2=true,x3=true];[x1=true,x2=false,x3=false];...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x1=true,x2=true,x3=true,x4=true];[x1=true,x2=true,x3=true,x4=true];...",Positive
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x1=true,x2=false,x3=true,x4=true];[x1=true,x2=true,x3=false,x4=true];...",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=true,x2=true,x3=false];[x1=true,x2=true,x3=true];[x1=true,x2=false,x3=false];...",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=false,x2=false,x3=false];[x1=false,x2=false,x3=true];[x1=false,x2=false,x3=false];...",Negative
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"To satisfy the LTL formula, we need to ensure all components hold: 1. **State valid with all true**: - [x1=true, x2=true, x3=true] 2. **All true again (to keep G condition)**: - [x1=true, x2=true, x3=true] This ensures the condition \( F(x1 \land x2 \land x3) \) is met infinitely often and maintains that \( G(...) \) holds. ###",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"For a negative trace, we need to violate at least one part of the formula:",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"** [x1=true,x2=true,x3=true,x4=true]; [x1=true,x2=true,x3=true,x4=true]; [x1=true,x2=false,x3=true,x4=true]; [x1=true,x2=true,x3=false,x4=true]; [x1=true,x2=true,x3=true,x4=false]; ... ###",Positive
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"** [x1=false,x2=false,x3=false,x4=false]; [x1=false,x2=true,x3=false,x4=false]; [x1=false,x2=false,x3=true,x4=false]; [x1=false,x2=false,x3=false,x4=true]; [x1=false,x2=false,x3=false,x4=false]; ...",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"** \[ [x1=false,x2=false,x3=false];[x1=false,x2=true,x3=false];[x1=false,x2=false,x3=true];[x1=true,x2=false,x3=false];... \]",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"** \[ [x1=true,x2=false,x3=false];[x1=true,x2=true,x3=false];[x1=false,x2=true,x3=false];[x1=false,x2=true,x3=true];[x1=true,x2=true,x3=true];... \] **",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=false,x2=true,x3=false];[x1=false,x2=true,x3=true];[x1=true,x2=true,x3=true];[x1=false,x2=true,x3=true];... ``` ###",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=true,x2=false,x3=false];[x1=true,x2=false,x3=true];[x1=true,x2=true,x3=false];[x1=false,x2=false,x3=false];... ```",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"** `[x2=true,x3=false,x1=false,x4=true];[x2=false,x3=true,x1=false,x4=false];[x2=true,x3=false,x1=true,x4=false];[x2=false,x3=false,x1=false,x4=false];[x2=false,x3=false,x1=false,x4=false];...`",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"** `[x2=false,x3=false,x1=false,x4=true];[x2=true,x3=true,x1=false,x4=true];[x2=false,x3=false,x1=true,x4=true];[x2=false,x3=false,x1=false,x4=true];[x2=true,x3=false,x1=true,x4=false];[x2=false,x3=true,x1=true,x4=false];...` ###",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"For a negative trace, we need a sequence where either `x1` or `x2` or `x3` fails to meet the required conditions. For example, if `x1` never becomes true or if `x3` is never true, the formula would not be satisfied.",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"To create a positive trace that satisfies the formula, we can have a sequence where `x1` becomes true, then `x2` ultimately becomes true at a future point, while also ensuring `x3` eventually becomes true with `x2` being true afterwards. Here is one possible positive trace: - [x1=false, x2=false, x3=false] - [x1=true, x2=false, x3=false] // fulfill F(x1) - [x1=true, x2=true, x3=false] // fulfill F(F(x2)) - [x1=true, x2=true, x3=true] // fulfill F(x3) - [x1=true, x2=true, x3=true] // remains true, fulfill U condition - [x1=true, x2=true, x3=true] // remains true until x2 is true - ... So the positive trace is: **Positive trace:** [x1=false, x2=false, x3=false]; [x1=true, x2=false, x3=false]; [x1=true, x2=true, x3=false]; [x1=true, x2=true, x3=true]; [x1=true, x2=true, x3=true];... ###",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=false,x2=true,x3=true];[x1=true,x2=true,x3=true];[x1=true,x2=true,x3=true];...",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=true,x2=true,x3=false];[x1=false,x2=true,x3=true];[x1=true,x2=true,x3=false];...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x2=false,x3=true,x4=true,x1=false];[x2=true,x3=true,x4=true,x1=false];[x2=false,x3=true,x4=true,x1=true];[x2=false,x3=true,x4=true,x1=true];...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x2=false,x3=false,x4=true,x1=false];[x2=true,x3=true,x4=true,x1=false];[x2=true,x3=true,x4=true,x1=true];[x2=true,x3=true,x4=true,x1=true];...",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=false, x2=false, x3=false];[x1=false, x2=false, x3=true];[x1=false, x2=false, x3=false];...",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=true, x2=false, x3=false];[x1=false, x2=true, x3=false];[x1=false, x2=true, x3=true];...",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x3=true,x1=false,x2=true]; [x3=true,x1=true,x2=true,x3=true]...",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x3=true,x1=true,x2=false]; [x3=false,x1=false,x2=false]...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x2=true,x3=false,x4=true,x1=false];[x2=false,x1=false,x3=true,x4=false];[x2=true,x3=false,x4=true,x1=false];[x2=true,x3=false,x4=false,x1=true];...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x2=true,x3=true,x4=true,x1=false];[x2=true,x1=true,x3=true,x4=true];[x2=true,x3=true,x4=true,x1=false];[x2=true,x3=true,x4=false,x1=true];...",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=true,x2=false,x3=false];[x1=false,x2=true,x3=true];[x1=true,x2=true,x3=true];[x1=true,x2=false,x3=false];[x1=false,x2=true,x3=false];[x1=true,x2=true,x3=true]...",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=false,x2=false,x3=false];[x1=true,x2=false,x3=true];[x1=false,x2=true,x3=false];[x1=true,x2=false,x3=true];[x1=false,x2=false,x3=true];[x1=true,x2=true,x3=false]...",Negative
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=false, x2=true, x3=false];[x1=false, x2=true, x3=false];[x1=true, x2=true, x3=true];[x1=false, x2=true, x3=false];...",Positive
G((x3->!x1 & x2) & ((x1 & x2) -> x3) & F(x1 & x2 & x3)),"[x1=true, x2=true, x3=false];[x1=false, x2=true, x3=false];[x1=true, x2=true, x3=false];[x1=false, x2=true, x3=false];...",Negative
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x1=false, x2=false, x3=false, x4=true]; [x1=false, x2=true, x3=true, x4=true]; [x1=true, x2=false, x3=false, x4=true]; [x1=false, x2=true, x3=false, x4=true]; [x1=false, x2=false, x3=false, x4=true]; ...",Positive
G (F(x2 & x3) & (X (x2 -> X(x1))) & G(x4 U x1) & F(x2)),"[x1=false, x2=false, x3=false, x4=false]; [x1=false, x2=true, x3=true, x4=false]; [x1=false, x2=false, x3=false, x4=false]; [x1=false, x2=false, x3=false, x4=false]; ...",Negative
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=false,x2=false,x3=false];[x1=true,x2=false,x3=false];[x1=true,x2=true,x3=false];[x1=false,x2=false,x3=true];[x1=false,x2=false,x3=false];[x1=false,x2=true,x3=true];...",Positive
F (x1 & F (x2)) & F (x3 & (!x3 U x2)),"[x1=false,x2=false,x3=false];[x1=true,x2=false,x3=false];[x1=false,x2=false,x3=true];[x1=false,x2=false,x3=false];...",Negative
